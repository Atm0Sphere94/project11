
//variables
const authData = {cohortId: 'cohort7',
                  serverUrl: 'http://95.216.175.5/',
                  authToken: '7758ef97-2052-4276-8215-8b9f07625725',
                };

const cardContainer = document.querySelector('.places-list');
const openEditFormButton = document.querySelector('.profile__edit-button');
const openPlaceFormButton = document.querySelector('.user-info__button');

//event listeners

openEditFormButton.addEventListener('click', () => {
  editPopup.open();
});
openPlaceFormButton.addEventListener('click', () => {
  placePopup.open();
});

//functions
const userInfo = (form, api) => new UserInfo(form, api);
const newCard = (cardData, template, api, container) => new Card(cardData, template, api, container);
const formValidator = (form) => new FormValidator(form);

//initializing class instances

const mestoApi = new Api(authData);
const cardList = new CardList(document.getElementById('card-sample'), cardContainer, mestoApi);
const editPopup = new Form(document.getElementById('edit'), formValidator(document.forms.editinfo), cardList, mestoApi);
const placePopup = new Form(document.getElementById('newplace'), formValidator(document.forms.new), cardList, mestoApi);
const picturePopup = new Popup(document.getElementById('picture'));
const currentUserInfo = userInfo(document.forms.editinfo, mestoApi);

//function calls
currentUserInfo.loadUserInfo();
cardList.render();



/*
  При открытии страницы карточки и данные пользователя загружаются, но к организации кода и к отправке данных на сервер есть ряд замечаний:

  Надо исправить:
  - согласно разделу "Требования к коду" задания -  необходимо для обмена с сервером создать класс Api, в его
  конструктор будут передаваться настроки сервера (адрес и ключ авторизации), а его методы должны
  выполнять запросы на сервер и возвращать промисы с данными
  Экземпляр класса Api создается в файле main.js и передается как параметр конструктора классам которым он необходим +

  - (res) => res.json() недостаточно, нужна также проверка, что запрос на сервер выполнился успешно и 
  если нет, то нужно возвращать отклоненный промис. Проверка выполняется с помощью проверки свойства res.ok 
  https://developer.mozilla.org/en-US/docs/Web/API/Response/ok
  Пример правильной обработки ошибки приведен в конце задания +

  - все изменения на странице должны происходить, только после того, как сервер ответил подтверждением.
  Если сервер не ответил, или ответил ошибкой, а данные на странице сохранятся, это может
  ввести пользователя в заблуждение. Сейчас данные пользователя сохраняются на странице и попап закрывается до ответа сервера +

  - при сохранении данных пользователя на сервер всегда отправляются данные 'Marie Skłodowska Curie',
  'Physicist and Chemist', должны отправляться данные которые пользователь ввел в поля формы +

  - у запроса к серверу в методе writeInfo отсутствует обработка ошибок +

  Для сдачи работы необходимо исправить все замечания из раздела "Надо исправить",
*/


/*

  Код стал гораздо лучше, но часть замечаний к организации кода осталась

  Надо исправить:
  - методы класса Api должны выполнять запросы на сервер и возвращать промисы с данными, сейчас класс
  Api сам выполняет отрисовку данных на странице - он знает все обо всем - где хранятся данные пользователя,
  откуда их взять, чтобы отправить, как отобразить карточки на странице. Это нарушает принцип единственной ответственности.
  Как вынести работу с данными я показал на примере метод getCards в классе Api

  - данные пользователя должны передаваться в метод setUserInfo как параметры, а не сам класс Api
  берет их со страницы

  - все изменения на странице должны происходить, только после того, как сервер ответил подтверждением
  Сейчас api.setUserInfo(); вызывается уже после того как данные отображены на странице

  Можно лучше:
  - не нужно вызывать в конструкторе класса UserInfo запрос к серверу

*/

//Сделал все что смог, надесюь просрочка на 40 минут не повлияет. Надеюсь на понимание
// Возник вопрос по методу SetUserInfo - Прошу покажите как надо....я чего только не пробовал

/*
  С методами получения данных теперь все более менее в порядке, но при сохранении 
  данных пользователя они так и берутся со страницы в классе Api и сохраняются на странице 
  до завершения запроса к серверу. Основная проблема почему у Вас не получилось это сделать - 
  метод setUserInfo класса UserInfo принимает на вход событие и делает event.preventDefault();, 
  это нарушает принцип единственной ответсвенности т.к. UserInfo должен отвечать только 
  за отображение данные, а не за обработку событий. Поэтому в setUserInfo нужно передавать данные пользователя
  Привел в editForm.addEventListener('submit', (event) => { пример кода , надеюсь он Вам поможет

  Итак, необходимо исправить:
  - данные пользователя должны передаваться в метод setUserInfo как параметры, а не сам класс Api
  берет их со страницы

  - все изменения на странице должны происходить, только после того, как сервер ответил подтверждением
  Сейчас api.setUserInfo(); вызывается уже после того как данные отображены на странице.


*/


/*

    К сожалению к прошлым проблемам добавились новые:

    Надо исправить:

    - проблема с обработкой ошибок - обработчики catch в методах класса Api расположены в середине цепочки блоков then,
      обработчик ошибок должен быть в самом конце т.е. в метода loadUserInfo и updateUserInfo, ндк он стоит не там
      где нужно иди его вообще нет +

    - вызов then( () => this.api.getUserInfo()) не имеет смысла т.к. getUserInfo 
     сам ничего не делает, только возвращает данные которые вернул сервер +

    - метод loadUserInfo не должен после получения данных сразу отправлять их обратно на сервер +

    - сохранение данных пользователя на странице выполняется до ответа сервера +

    // Пожалуй это крайняя попытка - либо дальше либо в академ. Я правда очень старался=) 


*/

/*

    В некоторых местах стало немного лучше, но к сожалению ошибки все ещё есть.
    Надо исправить:
    - в классе Card есть обращение к методам  api.deleteCard  api.renderLikes которые не реализованы и сейчас при лайке или удалении
    карточки падает ошибка +

    - в методах класса Api есть обработчики catch которые находятся в середине цепочки then
    т.е. из методов класса Api нужно убрать обработку ошибок  +

    - разместить обработку ошибок в конце цепочки блоков then , сейчас она есть не везде где нужно +

    - т.к. обработка ошибок реализована неверно, при сохранении данных пользователя данные сохраняются на странице
    даже если сервер не ответил подтверждением сохранения данных +

    Проверить правильность алгоритма сохранения данных пользователя можно так:
    1) открываете Chrome Dev Tools
    2) На вкладке Network устанавливаете переключатель в положение Offline  http://prntscr.com/qulalq
    тем самым эмулируя отсутствие интернета
    3) В окне редактирования профиля нажимаете кнопку "Сохранить" - окно не должно закрыться
    и данные не должны сохраниться на странице
    4) Переводим переключатель обратно в положение Online, опять включая интернет
    5) При нажатии на кнопку "Сохранить" - окно должно закрыться и данные должны сохраниться на странице

    Т.е. данные на странице сохраняются если от сервера пришло подтверждение

    Также на всякий случай приведу пример где должны располагаться обработчики ошибок:
    class Api {
      ...........
      getCards() { //метод для получения карточек с сервера
        return fetch(`${this.options.baseUrl}/cards`, { //возвращаем промис c данными
            headers: this.options.headers,
          })
          .then((res) => {    
            if (!res.ok) {  
              return Promise.reject(`Ошибка: ${res.status}`); 
            }
            return res.json(); 
          })
          //здесь обработки ошибок блоком catch быть не должно, она будет при вызове метода getCards 
      }
      ............
    }

    Использование метода getCards:
    api.getCards()          //вызываем метод класса Api для получения карточек с сервера
      .then((cards) => {    //получаем от сервера данные
          ........          //сюда попадаем, если запрос выполнился успешно и сервер вернул ответ, 
                            //обрабатываем полученные данные здесь 
      })
      .catch((err) => {     //если запрос на сервер завершился неудачно то здесь обрабатываем ошибку, в самом конце цепочки then
          console.log(err); //здесь обработка ошибок, например сюда попадем если нет интернета, пока достаточно вывести ошибку в консоль
      }); 
      .finally()            //здесь finally если он нужен


*/